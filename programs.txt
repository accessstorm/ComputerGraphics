[18/10, 9:40 pm] Jayavrata Sengupta: #include <conio.h>
#include <stdio.h>
#include <graphics.h>

void main() {
    int gd = DETECT, gm;
    float x, y, xc, yc, rx, ry, pk, pk1;

    clrscr();
    initgraph(&gd, &gm, "C:\\Turboc3\\BGI");

    printf("Midpoint Ellipse Drawing Algorithm\n");
    printf("Enter center for ellipse\nx: ");
    scanf("%f", &xc);
    printf("y: ");
    scanf("%f", &yc);
    printf("Enter x radius and y radius\nx radius: ");
    scanf("%f", &rx);
    printf("y radius: ");
    scanf("%f", &ry);

    x = 0;
    y = ry;

    pk = (ry * ry) - (rx * rx * ry) + (rx * rx) / 4;
    
    // Region 1
    while ((2 * x * ry * ry) < (2 * y * rx * rx)) {
        putpixel(xc + x, yc + y, 2);
        putpixel(xc - x, yc + y, 2);
        putpixel(xc + x, yc - y, 2);
        putpixel(xc - x, yc - y, 2);

        if (pk <= 0) {
            x = x + 1;
            pk1 = pk + (2 * ry * ry * x) + (ry * ry);
        } else {
            x = x + 1;
            y = y - 1;
            pk1 = pk + (2 * ry * ry * x) - (2 * rx * rx * y) + (ry * ry);
        }
        pk = pk1;
    }

    // Region 2
    pk = ((x + 0.5) * (x + 0.5) * ry * ry) + ((y - 1) * (y - 1) * rx * rx) - (rx * rx * ry * ry);

    while (y > 0) {
        putpixel(xc + x, yc + y, 2);
        putpixel(xc - x, yc + y, 2);
        putpixel(xc + x, yc - y, 2);
        putpixel(xc - x, yc - y, 2);

        if (pk > 0) {
            y = y - 1;
            pk1 = pk - (2 * rx * rx * y) + (rx * rx);
        } else {
            x = x + 1;
            y = y - 1;
            pk1 = pk + (2 * ry * ry * x) - (2 * rx * rx * y) + (rx * rx);
        }
        pk = pk1;
    }

    getch();
    closegraph();
}
[18/10, 9:45 pm] Jayavrata Sengupta: #include <graphics.h>
#include <conio.h>
#include <math.h>
#include <stdio.h>

void koch(int x1, int y1, int x2, int y2, int it) {
    float angle = 60 * M_PI / 180;
    int x3 = (2 * x1 + x2) / 3;
    int y3 = (2 * y1 + y2) / 3;
    int x4 = (x1 + 2 * x2) / 3;
    int y4 = (y1 + 2 * y2) / 3;

    int x = x3 + (x4 - x3) * cos(angle) - (y4 - y3) * sin(angle);
    int y = y3 + (x4 - x3) * sin(angle) + (y4 - y3) * cos(angle);

    if (it > 0) {
        koch(x1, y1, x3, y3, it - 1);
        koch(x3, y3, x, y, it - 1);
        koch(x, y, x4, y4, it - 1);
        koch(x4, y4, x2, y2, it - 1);
    } else {
        line(x1, y1, x3, y3);
        line(x3, y3, x, y);
        line(x, y, x4, y4);
        line(x4, y4, x2, y2);
    }
}

int main(void) {
    int gd = DETECT, gm;
    int x1 = 100, y1 = 300, x2 = 500, y2 = 300;

    initgraph(&gd, &gm, "C:\\Turboc3\\BGI");

    // Draw the Koch curve
    koch(x1, y1, x2, y2, 4);

    getch();
    closegraph();

    return 0;
}
[18/10, 9:54 pm] Jayavrata Sengupta: #include <stdio.h>
#include <graphics.h>
#include <dos.h>

void boundaryfill(int x, int y, int f_color, int b_color) {
    // Check if the current pixel is not the boundary color and not the fill color
    if (getpixel(x, y) != b_color && getpixel(x, y) != f_color) {
        // Set the pixel to the fill color
        putpixel(x, y, f_color);
        
        // Recursive calls to fill in all four directions
        boundaryfill(x + 1, y, f_color, b_color); // Right
        boundaryfill(x - 1, y, f_color, b_color); // Left
        boundaryfill(x, y + 1, f_color, b_color); // Down
        boundaryfill(x, y - 1, f_color, b_color); // Up
    }
}

int main() {
    int gm, gd = DETECT, radius;
    int x, y;

    // Get user input for circle center and radius
    printf("Enter x and y positions for circle\n");
    scanf("%d%d", &x, &y);
    printf("Enter radius of circle\n");
    scanf("%d", &radius);

    // Initialize graphics mode
    initgraph(&gd, &gm, "C:\\Turboc3\\BGI");

    // Draw the circle
    circle(x, y, radius);

    // Call the boundary fill function with fill color 4 (red) and boundary color 15 (white)
    boundaryfill(x, y, 4, 15);

    // Wait for a while to view the result
    delay(5000);

    // Close the graphics mode
    closegraph();

    return 0;
}
[18/10, 9:59 pm] Jayavrata Sengupta: #include <stdio.h>
#include <conio.h>
#include <graphics.h>
#include <dos.h>

void floodfill(int x, int y, int fill_color, int old_color) {
    // Check if the current pixel has the old color
    if (getpixel(x, y) == old_color) {
        // Set the pixel to the fill color
        putpixel(x, y, fill_color);
        delay(10);  // Add delay to visualize the fill process

        // Recursively call the flood fill function in all four directions
        floodfill(x + 1, y, fill_color, old_color); // Right
        floodfill(x - 1, y, fill_color, old_color); // Left
        floodfill(x, y + 1, fill_color, old_color); // Down
        floodfill(x, y - 1, fill_color, old_color); // Up
    }
}

void main() {
    int gd = DETECT, gm;

    // Initialize the graphics mode
    initgraph(&gd, &gm, "C:\\Turboc3\\BGI");

    // Draw a rectangle on the screen
    rectangle(50, 50, 100, 100);

    // Apply flood fill from an internal point within the rectangle (51, 51)
    // with a fill color of 4 (red) and an old color of 0 (black)
    floodfill(51, 51, 4, 0);

    // Wait for a key press to exit
    getch();

    // Close the graphics mode
    closegraph();
}






#include <stdio.h>
#include <graphics.h>
#include <conio.h>

void main() {
    int gd = DETECT, gm;
    int x, y, x1, y1, x2, y2, p, dx, dy;

    // Initialize the graphics mode
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");

    // Input coordinates of the first point
    printf("\nEnter the x-coordinate of the first point: ");
    scanf("%d", &x1);

    printf("\nEnter the y-coordinate of the first point: ");
    scanf("%d", &y1);

    // Input coordinates of the second point
    printf("\nEnter the x-coordinate of the second point: ");
    scanf("%d", &x2);

    printf("\nEnter the y-coordinate of the second point: ");
    scanf("%d", &y2);

    // Set initial points
    x = x1;
    y = y1;
    
    // Calculate dx and dy
    dx = x2 - x1;
    dy = y2 - y1;

    // Bresenham's algorithm
    p = 2 * dy - dx;
    
    while (x <= x2) {
        putpixel(x, y, YELLOW); // Draw pixel at (x, y)

        if (p < 0) {
            x = x + 1;
            p = p + 2 * dy;
        } else {
            x = x + 1;
            y = y + 1;
            p = p + 2 * dy - 2 * dx;
        }
    }

    getch(); // Wait for a key press
    closegraph(); // Close the graphics mode
}
